#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

#######################################
# Check workspace repos for GitHub Actions status and output JSON.
#
# Usage: actions-status [options]
#
# Options:
#   -h, --help     Show this help message
#   -v, --verbose  Enable verbose output
#
# Environment Variables:
#   ACTIONS_STATUS_CONFIG  Path to repos configuration file (default: bin/repos.yaml)
#
# Exit Codes:
#   0  Success
#   1  General error (missing dependency, file not found, etc.)
#   2  Invalid arguments
#
# Dependencies:
#   gh    - GitHub CLI (https://cli.github.com)
#   yq    - YAML query tool (https://github.com/mikefarah/yq)
#   jq    - JSON processor (https://stedolan.github.io/jq)
#
# Config File Format:
#   repos:
#     - owner/repo1
#     - owner/repo2
#######################################

# Colors for output (stderr only)
readonly RED='\033[0;31m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

#######################################
# Print error message and exit
# Arguments:
#   $@ - Error message
# Outputs:
#   Writes error to stderr
# Returns:
#   Exits with code 1
#######################################
die() {
  echo -e "${RED}ERROR:${NC} $*" >&2
  exit 1
}

#######################################
# Print warning message
# Arguments:
#   $@ - Warning message
# Outputs:
#   Writes warning to stderr
#######################################
warn() {
  echo -e "${YELLOW}WARNING:${NC} $*" >&2
}

#######################################
# Print info message
# Arguments:
#   $@ - Info message
# Outputs:
#   Writes info to stderr
#######################################
info() {
  echo -e "${BLUE}INFO:${NC} $*" >&2
}

#######################################
# Check if command exists
# Arguments:
#   $1 - Command name
# Returns:
#   0 if command exists, 1 otherwise
#######################################
command_exists() {
  command -v "$1" &>/dev/null
}

#######################################
# Check all required dependencies
# Returns:
#   0 if all dependencies exist, exits with 1 otherwise
#######################################
check_dependencies() {
  local missing=()
  local -a deps=("gh" "yq" "jq")

  for cmd in "${deps[@]}"; do
    if ! command_exists "$cmd"; then
      missing+=("$cmd")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    die "Missing required dependencies: ${missing[*]}"
  fi
}

#######################################
# Show help message
# Outputs:
#   Writes help to stdout
#######################################
show_help() {
  head -n 31 "${BASH_SOURCE[0]}" | tail -n 27
}

#######################################
# Parse command line arguments
# Globals:
#   VERBOSE - Set to 1 if verbose mode enabled
# Arguments:
#   $@ - Command line arguments
# Returns:
#   0 on success, 2 on invalid arguments
#######################################
parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -v|--verbose)
        VERBOSE=1
        shift
        ;;
      *)
        echo "Unknown option: $1" >&2
        return 2
        ;;
    esac
  done
}

#######################################
# Get the config file path
# Globals:
#   SCRIPT_DIR
# Arguments:
#   None
# Outputs:
#   Writes config path to stdout
# Returns:
#   0 on success, exits with 1 if file not found
#######################################
get_config_file() {
  local config_file="${ACTIONS_STATUS_CONFIG:-}"

  if [[ -z "$config_file" ]]; then
    config_file="${SCRIPT_DIR}/repos.yaml"
  fi

  # Ensure it's an absolute path
  if [[ ! "$config_file" = /* ]]; then
    config_file="$(cd "$(dirname "$config_file")" && pwd)/$(basename "$config_file")"
  fi

  if [[ ! -f "$config_file" ]]; then
    die "Config file not found: $config_file"
  fi

  echo "$config_file"
}

#######################################
# Read repos from YAML config file
# Arguments:
#   $1 - Path to config file
# Outputs:
#   Writes repo names to stdout (one per line)
# Returns:
#   0 on success, exits with 1 on error
#######################################
read_repos() {
  local config_file="$1"

  if ! yq '.repos[]' "$config_file" 2>/dev/null; then
    die "Failed to parse repos from config file: $config_file"
  fi
}

#######################################
# Fetch all runs for a repo from GitHub Actions
# Globals:
#   VERBOSE
# Arguments:
#   $1 - Repository in format owner/name
# Outputs:
#   Writes JSON array of runs to stdout
# Returns:
#   0 on success
#######################################
fetch_repo_status() {
  local repo="$1"

  [[ $VERBOSE -eq 1 ]] && info "Fetching runs for $repo..." >&2

  gh run list \
    --repo "$repo" \
    --limit 100 \
    --json workflowName,databaseId,headBranch,conclusion,url,createdAt,updatedAt,headSha,actor \
    2>/dev/null || {
    warn "Failed to fetch runs for $repo" >&2
    echo "[]"
    return 0
  }
}

#######################################
# Process runs by grouping by workflow, keeping latest per workflow
# Arguments:
#   $1 - Repository name
#   $2 - JSON array of runs
# Outputs:
#   Writes JSON object with repo and workflows array to stdout
# Returns:
#   0 on success
#######################################
process_repo_workflows() {
  local repo="$1"
  local runs_json="$2"

  # Group by workflow, keep latest (first in list since gh sorts by date desc)
  # Output one JSON object with nested workflows array
  jq \
    --arg repo "$repo" \
    'group_by(.workflowName) |
     map({
       name: .[0].workflowName,
       run_id: .[0].databaseId,
       status: (if .[0].conclusion == null then "in_progress" else .[0].conclusion end),
       branch: .[0].headBranch,
       head_sha: .[0].headSha,
       actor: .[0].actor.login,
       created_at: .[0].createdAt,
       duration_seconds: ((.[0].updatedAt | fromdateiso8601) - (.[0].createdAt | fromdateiso8601) | floor),
       url: .[0].url
     }) |
     {
       repo: $repo,
       workflows: .
     }' \
    <<< "$runs_json"
}

#######################################
# Main function
# Globals:
#   VERBOSE, SCRIPT_DIR
# Arguments:
#   $@ - Command line arguments
# Returns:
#   0 on success, 1 on error, 2 on invalid arguments
#######################################
main() {
  parse_args "$@" || return 2

  check_dependencies

  # Set SCRIPT_DIR to directory containing this script
  local SCRIPT_DIR
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

  local config_file
  config_file="$(get_config_file)"

  [[ $VERBOSE -eq 1 ]] && info "Using config file: $config_file" >&2

  # Read repos from config into array (using while loop for macOS compatibility)
  local repos=()
  while IFS= read -r repo; do
    [[ -n "$repo" ]] && repos+=("$repo")
  done < <(read_repos "$config_file")

  [[ $VERBOSE -eq 1 ]] && info "Found ${#repos[@]} repos to check" >&2

  # Create temp file for collecting repos with workflows
  local temp_repos
  temp_repos=$(mktemp)
  trap "rm -f '$temp_repos'" EXIT

  local total_repos=${#repos[@]}
  local total_workflows=0
  local status_counts
  status_counts='{"success": 0, "failure": 0, "in_progress": 0, "cancelled": 0, "skipped": 0}'

  # Fetch runs for each repo
  for repo in ${repos[@]+"${repos[@]}"}; do
    # Skip empty lines
    [[ -z "$repo" ]] && continue

    local runs_json
    runs_json=$(fetch_repo_status "$repo")

    # Check if there are any runs for this repo
    if [[ $(echo "$runs_json" | jq 'length') -gt 0 ]]; then
      # Process workflows and append to temp file
      process_repo_workflows "$repo" "$runs_json" >> "$temp_repos"
    fi
  done

  # Generate timestamp in ISO 8601 format
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Build and output final JSON
  if [[ -s "$temp_repos" ]]; then
    # File has content - slurp JSON objects and compute summary
    jq \
      --arg timestamp "$timestamp" \
      --argjson total_repos "$total_repos" \
      -s \
      '{
        timestamp: $timestamp,
        repos: .,
        summary: {
          total_repos: $total_repos,
          total_workflows: (map(.workflows | length) | add),
          success: (map(.workflows[] | select(.status == "success")) | length),
          failure: (map(.workflows[] | select(.status == "failure")) | length),
          in_progress: (map(.workflows[] | select(.status == "in_progress")) | length),
          cancelled: (map(.workflows[] | select(.status == "cancelled")) | length),
          skipped: (map(.workflows[] | select(.status == "skipped")) | length)
        }
      }' < "$temp_repos"
  else
    # No runs - output empty results
    jq \
      --arg timestamp "$timestamp" \
      --argjson total_repos "$total_repos" \
      -n \
      '{
        timestamp: $timestamp,
        repos: [],
        summary: {
          total_repos: $total_repos,
          total_workflows: 0,
          success: 0,
          failure: 0,
          in_progress: 0,
          cancelled: 0,
          skipped: 0
        }
      }'
  fi
}

# Global variables
VERBOSE=0

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
