#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

#######################################
# Check workspace repos for GitHub Actions failures and output JSON.
#
# Usage: actions-fails [options]
#
# Options:
#   -h, --help     Show this help message
#   -v, --verbose  Enable verbose output
#
# Environment Variables:
#   ACTIONS_FAILS_CONFIG  Path to repos configuration file (default: claudescripts/repos.yaml)
#
# Exit Codes:
#   0  Success
#   1  General error (missing dependency, file not found, etc.)
#   2  Invalid arguments
#
# Dependencies:
#   gh    - GitHub CLI (https://cli.github.com)
#   yq    - YAML query tool (https://github.com/mikefarah/yq)
#   jq    - JSON processor (https://stedolan.github.io/jq)
#
# Config File Format:
#   repos:
#     - owner/repo1
#     - owner/repo2
#######################################

# Colors for output (stderr only)
readonly RED='\033[0;31m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

#######################################
# Print error message and exit
# Arguments:
#   $@ - Error message
# Outputs:
#   Writes error to stderr
# Returns:
#   Exits with code 1
#######################################
die() {
  echo -e "${RED}ERROR:${NC} $*" >&2
  exit 1
}

#######################################
# Print warning message
# Arguments:
#   $@ - Warning message
# Outputs:
#   Writes warning to stderr
#######################################
warn() {
  echo -e "${YELLOW}WARNING:${NC} $*" >&2
}

#######################################
# Print info message
# Arguments:
#   $@ - Info message
# Outputs:
#   Writes info to stderr
#######################################
info() {
  echo -e "${BLUE}INFO:${NC} $*" >&2
}

#######################################
# Check if command exists
# Arguments:
#   $1 - Command name
# Returns:
#   0 if command exists, 1 otherwise
#######################################
command_exists() {
  command -v "$1" &>/dev/null
}

#######################################
# Check all required dependencies
# Returns:
#   0 if all dependencies exist, exits with 1 otherwise
#######################################
check_dependencies() {
  local missing=()
  local -a deps=("gh" "yq" "jq")

  for cmd in "${deps[@]}"; do
    if ! command_exists "$cmd"; then
      missing+=("$cmd")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    die "Missing required dependencies: ${missing[*]}"
  fi
}

#######################################
# Show help message
# Outputs:
#   Writes help to stdout
#######################################
show_help() {
  head -n 32 "${BASH_SOURCE[0]}" | tail -n 31
}

#######################################
# Parse command line arguments
# Globals:
#   VERBOSE - Set to 1 if verbose mode enabled
# Arguments:
#   $@ - Command line arguments
# Returns:
#   0 on success, 2 on invalid arguments
#######################################
parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -v|--verbose)
        VERBOSE=1
        shift
        ;;
      *)
        echo "Unknown option: $1" >&2
        return 2
        ;;
    esac
  done
}

#######################################
# Get the config file path
# Globals:
#   SCRIPT_DIR
# Arguments:
#   None
# Outputs:
#   Writes config path to stdout
# Returns:
#   0 on success, exits with 1 if file not found
#######################################
get_config_file() {
  local config_file="${ACTIONS_FAILS_CONFIG:-}"

  if [[ -z "$config_file" ]]; then
    config_file="${SCRIPT_DIR}/repos.yaml"
  fi

  # Ensure it's an absolute path
  if [[ ! "$config_file" = /* ]]; then
    config_file="$(cd "$(dirname "$config_file")" && pwd)/$(basename "$config_file")"
  fi

  if [[ ! -f "$config_file" ]]; then
    die "Config file not found: $config_file"
  fi

  echo "$config_file"
}

#######################################
# Read repos from YAML config file
# Arguments:
#   $1 - Path to config file
# Outputs:
#   Writes repo names to stdout (one per line)
# Returns:
#   0 on success, exits with 1 on error
#######################################
read_repos() {
  local config_file="$1"

  if ! yq '.repos[]' "$config_file" 2>/dev/null; then
    die "Failed to parse repos from config file: $config_file"
  fi
}

#######################################
# Fetch failures for a repo from GitHub Actions
# Globals:
#   VERBOSE
# Arguments:
#   $1 - Repository in format owner/name
# Outputs:
#   Writes JSON array of failures to stdout
# Returns:
#   0 on success
#######################################
fetch_repo_failures() {
  local repo="$1"

  [[ $VERBOSE -eq 1 ]] && info "Fetching failures for $repo..." >&2

  gh run list \
    --repo "$repo" \
    --status failure \
    --limit 100 \
    --json workflowName,databaseId,headBranch,conclusion,url \
    2>/dev/null || {
    warn "Failed to fetch failures for $repo" >&2
    echo "[]"
    return 0
  }
}

#######################################
# Group failures by workflow, keeping latest per workflow
# Arguments:
#   $1 - Repository name
#   $2 - JSON array of failures
# Outputs:
#   Writes JSON objects (one per line) to stdout
# Returns:
#   0 on success
#######################################
group_failures_by_workflow() {
  local repo="$1"
  local failures_json="$2"

  # Group by workflow, keep latest (first in list since gh sorts by date desc)
  # Output one JSON object per line for each grouped workflow failure
  jq \
    --arg repo "$repo" \
    'group_by(.workflowName) |
     map({
       repo: $repo,
       run_id: .[0].databaseId,
       workflow: .[0].workflowName,
       branch: .[0].headBranch,
       conclusion: .[0].conclusion,
       url: .[0].url
     }) |
     .[]' \
    <<< "$failures_json"
}

#######################################
# Main function
# Globals:
#   VERBOSE, SCRIPT_DIR
# Arguments:
#   $@ - Command line arguments
# Returns:
#   0 on success, 1 on error, 2 on invalid arguments
#######################################
main() {
  parse_args "$@" || return 2

  check_dependencies

  # Set SCRIPT_DIR to directory containing this script
  local SCRIPT_DIR
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

  local config_file
  config_file="$(get_config_file)"

  [[ $VERBOSE -eq 1 ]] && info "Using config file: $config_file" >&2

  # Read repos from config into array (using while loop for macOS compatibility)
  local repos=()
  while IFS= read -r repo; do
    [[ -n "$repo" ]] && repos+=("$repo")
  done < <(read_repos "$config_file")

  [[ $VERBOSE -eq 1 ]] && info "Found ${#repos[@]} repos to check" >&2

  # Create temp file for collecting failures
  local temp_failures
  temp_failures=$(mktemp)
  trap "rm -f '$temp_failures'" EXIT

  local repos_with_failures=0
  local total_repos=${#repos[@]}

  # Fetch failures for each repo
  for repo in ${repos[@]+"${repos[@]}"}; do
    # Skip empty lines
    [[ -z "$repo" ]] && continue

    local failures_json
    failures_json=$(fetch_repo_failures "$repo")

    # Check if there are any failures for this repo
    if [[ $(echo "$failures_json" | jq 'length') -gt 0 ]]; then
      repos_with_failures=$((repos_with_failures + 1))

      # Group failures by workflow and append to temp file
      group_failures_by_workflow "$repo" "$failures_json" >> "$temp_failures"
    fi
  done

  # Generate timestamp in ISO 8601 format
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Build and output final JSON
  if [[ -s "$temp_failures" ]]; then
    # File has content - slurp JSON objects and build output
    jq \
      --arg timestamp "$timestamp" \
      --argjson total_repos "$total_repos" \
      --argjson repos_with_failures "$repos_with_failures" \
      -s \
      '{
        timestamp: $timestamp,
        failures: .,
        summary: {
          total_repos: $total_repos,
          repos_with_failures: $repos_with_failures,
          total_failures: (. | length)
        }
      }' < "$temp_failures"
  else
    # No failures - output empty results
    jq \
      --arg timestamp "$timestamp" \
      --argjson total_repos "$total_repos" \
      -n \
      '{
        timestamp: $timestamp,
        failures: [],
        summary: {
          total_repos: $total_repos,
          repos_with_failures: 0,
          total_failures: 0
        }
      }'
  fi
}

# Global variables
VERBOSE=0

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
